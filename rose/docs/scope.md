# Scope

Scope is handled by a scope manager. The scope manager is responsible for managing a hierarchy of scopes. At the top of the hierarchy of scopes is the root scope. The root scope represents main --- the entry point of the program. In an interpreted program, the entry module is main. In a compiled program, this is also true. However, there can be an explicitly defined main method. In both an interpreted and compiled program, the main routine of the main module is dispatched by default. If the main routine is dispatched, then a new scope node called main is branched from the root scope.

Each scope has three responsibilities. The first is to store all of the bindings and definitions that can be used via an identifier hash. Scopes are hierarchical. Therefore, the second responsibility is for a scope to store a reference to its outer scope. This allows for bindings and definitions that were declared in the outer scope to be accessible within the current scope. The third is to allow for delegation to other dispatchers. This takes place in the form of passing objects.

Objects are another kind of context. If it hasn't already been made clear, every context has a scope which means that objects contain scope and therefore, objects also container their own dispatcher. The dispatcher for an object can be the same for all objects of the same type. This is a class dispatcher which is defined by the class definition. An object can also have a unique dispatcher. This is a prototypical dispatcher.

When an object is brought into scope, messages can be delegated to the dispatcher of that object. This is done via delegation. Delegation is different than dispatch in only one respect. Dispatch uses the current scope to determine which binding or variable to use. Delegation uses the dispatcher of the first argument of the routine to determine which binding or variable to use.

Delegation is handled in one of two ways.

First, class dispatchers can be represented as singletons which are accessible in all scopes. This is done by attaching all class dispatchers to the dispatcher of the root node. To use a class dispatcher, the root dispatcher is passed the hash of the symbolic type of the class. This provides the dispatcher for that class which can then be used for dispatch. It should be noted that class dispatchers don't have to placed on the root dispatcher. They can be placed on any scope's dispatcher. However, class dispatchers that are not placed on the root dispatcher are only accessible within a sub-hierarchy of the scopes that exist within the program. These sub-hierarchies are often employed as modules. However, anything that has scope can also have a sub-hierarchy, so blocks, functions, classes, and modules can all have localized class dispatchers.

The second approach is for prototypes. Since prototypes have a unique dispatcher, the dispatch table of the prototype must be passed with the reference. The disptach table can be passed by reference, but, even so, the use of many prototypes can introduce additional overhead that won't be present with class dispatchers. However, they do provide the benefit of a greater amount of flexibility.

To allow for both class dispatchers and prototypical dispatchers, a distinction must be made so that it is clear when a class dispatcher will be used and when a prototypical dispatcher will be used. This distinction is made via the dyn reserved word. A type which is marked as dyn (dynamic) has a reference to a dispatch table which is to be used for delegation. This allows prototypical dispatchers to be utilized when dynamic types are allowed. It should be noted that the reference to a dispatch table utilized by a dynamic type doesn't have to be a prototypical dispatcher. It can also be a class dispatcher. This allows for prototypes and classes to be conveniently mixed together when a dynamic type is used.

Another convenient benefit of allowing dynamic types is that they can be used for polymorphism. In be more clear, we can treat prototypes as another approach to polymorphism. Thus prototypes, interfaces, and inheritance can also be utilized via dynamic types.
