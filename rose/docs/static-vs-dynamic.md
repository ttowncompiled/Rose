# Static vs Dynamically Typed Languages

One debate that can take place in the landscape of programming languages is whether or not a PL should be dynamically or statically typed. The answer in this case, like it most cases, is that it depends. There are pros and cons to both. Two notable benefits to using a dynamically typed language in contrast to a statically typed language is duck typing and lack of explicit references to types. Duck typing is a huge benefit because it allows us to express notions of common behavior between objects. Duck typing is realized better in dynamically typed programming languages more often (Go is the exception) because statically typed languages require that common behavior is represented through explicitly defined and intentionally implemented traits. This point needs to be expanded and addressed further.

Duck typing is form of behavioral abstraction that can only be captured in most statically typed languages with the notion of an interface. In some sense, statically typed languages take the approach that since they have already implemented a rectange and since a square is just a type of rectangle, there is no need to implement a square. This is wrong when it comes to duck typing for a few good reasons. 1) Implementing a duck type as an explicit interface poses a barrier to utilizing a duck type. In almost every statically typed language, it is far easier to type check and type cast then it is to define and utilize an interface. 2) Explicit interfaces have to be maintained. By implementing a duck type as an explicit interface, the duck type now has to be maintained and can more easily enter into legacy code. 3) When implemented as an interface, mutations to duck types are signficantly more severe. Since the duck type is explicitly defined as an interface and the interface is intentionally implemented by classes, any change to a duck type imposes the requirement for change on all implementing types. 4) Interfaces must be intentionally implemented. In statically typed languages (Go being the exception), a duck type only applies to an object if the class of that object intentionally implemented the interface. This poses a barrier to the reuse of objects since objects have to be contracturally tied to an interface just to participate in a duck type. It poses a barrier to duck typing across libraries because numerous adapters have to be developed to map classes from different libraries to an implementation of the duck type. This also comes with a higher performance cost.

A major benefit of statically typed languages is the enforcement of type as it pertains to parameters. By having statically typed parameters, it is clear what behavioral inputs or data inputs a function requires to perform its routine. In some sense, statically typed parameters afford functions the opportunity to outline a contract with their caller. This specificity is important for having well-defined integrations of code and for preventing and catching latent bugs. If functions do not have statically typed parameters, then it isn't always obvious that changes to an object could break a function. The trick is to make sure that the level of impact that any single mutation has to a type is limited to the minimum necessary.

To this end, I think there is much to be desired in programming languages which operate as if inferred typing is the default. Since types are inferred rather than explicitly defined, mutations to types which should be a one-liner change don't ripple across source code. This is done while still preserving types which allows the compiler or interpreter to check if a break has been introduced through mutation to code.

One of the flaws that's introduce by dynamically typed languages is the use of a default any type. The use of a default any type is more of an obfuscation rather than an abstraction. It is no longer clear where a specific type is relavent across a repository.

It would seem to me that a desirable programming language would operate like a dynamically typed language while still preserving the type of each object. Inferred types satisfy this requirement. The following constitutes a list of features which I believe would be desirable to see in a programming language.

* Is statically typed with type inference so that types can be explicitly defined when necessary.
* The ability to infer duck types.
* The ability to define private interfaces which can be used as well-defined duck types.
* The ability to enforce that arguments implement a duck type.
* This enforcement of duck types should come at no-cost to the runtime of a compiled program. In other words, duck typing should be checked at compile-time.
* Lazy application of duck type checking during an interpretive execution, so that the interpretive runtime performance does not suffer due to the affordance given to duck typing in a statically typed language.
